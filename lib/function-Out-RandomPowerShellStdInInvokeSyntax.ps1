
Function Out-RandomPowerShellStdInInvokeSyntax {
    <#
.SYNOPSIS

HELPER FUNCTION :: Generates randomized PowerShell syntax for invoking a command passed to powershell.exe via standard input.

Invoke-Obfuscation Function: Out-RandomPowerShellStdInInvokeSyntax
Author: David Sass (@sassdawe)
License: Apache License, Version 2.0
Required Dependencies: Out-ObfuscatedTokenCommand, Out-EncapsulatedInvokeExpression (found in Out-ObfuscatedStringCommand.ps1)
Optional Dependencies: None
 
.DESCRIPTION

Out-RandomPowerShellStdInInvokeSyntax generates random PowerShell syntax for invoking a command passed to powershell.exe via standard input. This technique is included to show the Blue Team that powershell.exe's command line arguments may not contain any contents of the command itself, but these could be stored in the parent process if passed to powershell.exe via standard input.

.EXAMPLE

C:\PS> Out-RandomPowerShellStdInInvokeSyntax

(  ^& ('v'+( 'aR'+ 'Iabl'  )  + 'E' ) ('exE'+'CUTiOnco'  +'n'+ 'TeX'  + 't' ) -Val).\"INvOKec`oMm`A`ND\".\"invO`K`es`CRiPt\"(${I`N`puT} )

.NOTES

This cmdlet is a helper function for Out-PowerShellLauncher's more sophisticated $LaunchType options where the PowerShell command is passed to powershell.exe via standard input for command line obfuscation benefits.
This is a personal project developed by Daniel Bohannon while an employee at MANDIANT, A FireEye Company.

.LINK

http://www.danielbohannon.com
#>
    
    # Build out random PowerShell stdin syntax like:
    # | powershell -      <-- default to this if $NoExit flag is defined because this will cause an error for the other options
    # | powershell IEX $Input
    # | powershell $ExecutionContext.InvokeCommand.InvokeScript($Input)
    # Also including numerous ways to invoke with $ExecutionContext as a variable, including Get-Variable varname, Get-ChildItem Variable:varname, Get-Item Variable:varname, etc.
    $ExecContextVariables = @()
    $ExecContextVariables += '(' + (Get-Random -Input @('DIR', 'Get-ChildItem', 'GCI', 'ChildItem', 'LS', 'Get-Item', 'GI', 'Item')) + ' ' + "'variable:" + (Get-Random -Input @('ex*xt', 'ExecutionContext')) + "').Value"
    $ExecContextVariables += '(' + (Get-Random -Input @('Get-Variable', 'GV', 'Variable')) + ' ' + "'" + (Get-Random -Input @('ex*xt', 'ExecutionContext')) + "'" + (Get-Random -Input (').Value', (' ' + ('-ValueOnly'.SubString(0, (Get-Random -Minimum 3 -Maximum ('-ValueOnly'.Length + 1)))) + ')')))
    # Select random option from above.
    $ExecContextVariable = (Get-Random -Input $ExecContextVariables)

    $RandomInputVariable = (Get-Random -Input @('$Input', '${Input}'))

    # Generate random invoke operation syntax.
    # 50% split between using $ExecutionContext invocation syntax versus IEX/Invoke-Expression/variable-obfuscated-'iex' syntax generated by Out-EncapsulatedInvokeExpression.
    $ExpressionToInvoke = $RandomInputVariable
    If (Get-Random -Input @(0..1)) {
        # Randomly decide on invoke operation since we've applied an additional layer of string manipulation in above steps.
        $InvokeOption = Out-EncapsulatedInvokeExpression $ExpressionToInvoke
    }
    Else {
        $InvokeOption = (Get-Random -Input @('$ExecutionContext', '${ExecutionContext}', $ExecContextVariable)) + '.InvokeCommand.InvokeScript(' + ' ' * (Get-Random -Minimum 0 -Maximum 3) + $ExpressionToInvoke + ' ' * (Get-Random -Minimum 0 -Maximum 3) + ')'
    }

    # Random case of $InvokeOption.
    $InvokeOption = ([Char[]]$InvokeOption.ToLower() | ForEach-Object { $Char = $_; If (Get-Random -Input (0..1)) { $Char = $Char.ToString().ToUpper() } $Char }) -Join ''

    # If $NoExit flag is defined in calling function then default to - stdin syntax. It will cause errors for other syntax options.
    If ($NoExit) {
        $InvokeOption = '-'
    }

    # Set $PowerShellStdIn to value of $InvokeOption.
    $PowerShellStdIn = $InvokeOption

    # Random case of $PowerShellStdIn.
    $PowerShellStdIn = ([Char[]]$PowerShellStdIn.ToLower() | ForEach-Object { $Char = $_; If (Get-Random -Input (0..1)) { $Char = $Char.ToString().ToUpper() } $Char }) -Join ''

    # Run random PowerShell Stdin operation through the appropriate token obfuscators.
    If ($PowerShellStdIn -ne '-') {
        # Run through all available token obfuscation functions in random order.
        $InvokeOption = Out-ObfuscatedTokenCommand -ScriptBlock ([ScriptBlock]::Create($InvokeOption))
        $InvokeOption = Out-ObfuscatedTokenCommand -ScriptBlock ([ScriptBlock]::Create($InvokeOption)) 'RandomWhitespace' 1
    }
    
    # For obfuscated commands generated for $PowerShellStdIn syntax, single-escape & < > and | characters for cmd.exe.
    ForEach ($Char in @('<', '>', '|', '&')) {
        # Remove single escaping and then escape all characters. This will handle single-escaped and not-escaped characters.
        If ($PowerShellStdIn.Contains("$Char")) {
            $PowerShellStdIn = $PowerShellStdIn.Replace("$Char", "^$Char")
        }
    }
    
    # Escape double-quote with backslash for powershell.exe.
    If ($PowerShellStdIn.Contains('"')) {
        $PowerShellStdIn = $PowerShellStdIn.Replace('"', '\"')
    }

    Return $PowerShellStdIn
}
